# Insecure deserialization zaifliklarini exploit qilish

## Insecure deserialization zaifliklarini exploit qilish

Ushbu bo'limda biz **PHP**, **Ruby** va **JAVA** dasturlash tillaridagi Deserialization misollaridan foydalanib **Insecure Deserialization** zaifliklarini qanday qilib exploit qilish mumkinligini o'rgatamiz. Biz Insecure Deserialization ni exploit qilish odamlar o'ylaganidanda ancha muncha osonroq ekanligiga umid qilamiz.

Va yana sizga o'zingizning deserialization ga asoslangan katta xujumlaringizni qanday amalga oshirishingiz mumkin ekanligini o'rgatamiz. Garchi bularni amalga oshirish uchun sizga source code ga kirish kerak bo'lsada, ularni asosiy konseptsiyalarini o'rganganingizdan so'ng buni amalga oshirish osonroq bo'ladi. Ayniqsa biz quyidagi mavzularga bor e'tiborimizni qaratamiz:

* [Qanday qilib Insecure Deserialization ni aniqlash mumkin](insecure-deserialization-zaifliklarini-exploit-qilish#qanday-qilib-insecure-deserialization-ni-aniqlash-mumkin)
* [Websayt kutgan serialized obyektlarga o'zgartirish kiritish](insecure-deserialization-zaifliklarini-exploit-qilish#serialized-obyektlarga-ozgartirish-kiritish)
* [Zararli ma'lumotni web saytning xavfli funksionalligiga o'tkazish](insecure-deserialization-zaifliklarini-exploit-qilish#websayt-funksionalligidan-foydalanish)
* [Ixtiyoriy obyektlarni kiritish](insecure-deserialization-zaifliklarini-exploit-qilish#ixtiyoriy-obyektlarni-kiritish)
* [Xavfli metod gadjetlariga ma'lumotlar oqimini boshqarish uchun bo'g'lamli metod chaqiruvlarini amalga oshirish](insecure-deserialization-zaifliklarini-exploit-qilish#gadjet-boglamlari)
* [O'zingizni Deserialization exploitingizni yaratish](insecure-deserialization-zaifliklarini-exploit-qilish#ozingizning-exploitingizni-yaratish)
* [PHAR Deserialization](insecure-deserialization-zaifliklarini-exploit-qilish#phar-deserialization)

:::info **Eslatma**
Garchi juda ko'p laboratoriyalar PHP asosida bo'lsada, bu usullar boshqa dasturlash tillarida ham shunday amalga oshiriladi.
:::

## Qanday qilib Insecure Deserialization ni aniqlash mumkin ? <a href="#qanday-qilib-insecure-deserialization-ni-aniqlash-mumkin" id="qanday-qilib-insecure-deserialization-ni-aniqlash-mumkin"></a>

Insecure Deserialization ni aniqlash judayam sodda hisoblanadi. Audit paytida siz websaytga uzatilayotgan barcha ma'lumotlarni ko'rib chiqishingiz va **Serialized** ma'lumotlarga o'xshash narsalarni aniqlashga harakat qilishingiz kerak. Agar siz ularning formatini turli dasturlash tillarida qanday ishlatilishini bilsangiz Serialized ma'lumotlarni tezda topishingiz mumkin. Bu bo'limda biz **PHP** va **Java** dasturlash tillarida serialized ma'lumotlardan misollar ko'rsatamiz. Agar serialized ma'lumotni aniqlasangiz uni xohlaganingizcha test qilishingiz mumkin, chunki siz uni boshqara olasiz.

:::tip **Maslahat**
[Burp Scanner](https://portswigger.net/burp/vulnerability-scanner) [Burp Suite Proffessional](https://portswigger.net/burp/pro) foydalanuvchilarini HTTPning request va response xabarlarida serialized ma'lumotlar borligini flag bilan ogohlantiradi.
:::

### PHP serialization format <a href="#php-serialization-format" id="php-serialization-format"></a>

PHP, har bir obyektnining uzunligini matn va raqamlar orqali ifodalab inson tushuna oladigan string formatidan foydalanadi. Masalan, `User` obyektini, attributlari bilan ko'rib chiqaylik:

```php
$user->name = "carlos";
$user->isLoggedIn = true;
```

Qachonki u serialized malumotga o'tkazilsa quyidagicha ko'rinishga keladi:

```php
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```

Buni mana bunday ajratib tariflash mumkin:

* `O:4:"User"` - 4 ta belgidan iborat `User` nomli klassga ega obyekt
* `2` - u obyektda 2 ta attribut bor
* `s:4:"name"` - birinchi attributni kaliti 4 ta belgidan iborat va u `name`
* `s:6:"carlos"` - birinchi attributni qiymati 6 ta belgidan iborat va u `carlos`
* `s:10:"isLoggedIn"` - ikkinchi attributni kaliti 10 ta belgidan iborat va u `isLoggedIn`
* `b:1` - ikkinchi attributning qiymati boolean qiymat bo'lib u: `true`

Serialization uchun PHP ning nativ metodlari bu `serialize()` va `unserialize()` hisoblanadi. Agarda sizda source code-ga kirish imkoniyati bo'lsa, unda siz koddan `unserialize()` metodidan foydalanilgan har qanday qismni topishingiz kerak.

### Java Serialization format <a href="#java-serialization-format" id="java-serialization-format"></a>

Ba'zi dasturlash tillari, Java ham, ikkilik sanoq sistemasiga asoslangan serialization formatlaridan foydalanadi. Bu ma'lumotlarni o'qish uchun ancha muncha qiyinchilik tug'diradi, Java obyektlari har doim encodelangan `ac ed` hexadecimal va `r00` Base64 kabi bir xil baytlar bilan boshlanadi.

Har qanaqa tur uchun serialized yoki deserialized obyekt yasash uchun siz `java.io.Serializable` ni amalga oshirishingiz mumkin. Agarda sizda source code-ga kirish imkoni bo'lsa unda siz `InputStream` dan kiruvchi ma'lumotlarni deserialize qiladigan `readObject()` metodiga e'tiboringizni qarating.

## Serialized obyektlarga o'zgartirish kiritish <a href="#serialized-obyektlarga-ozgartirish-kiritish" id="serialized-obyektlarga-ozgartirish-kiritish"></a>

Ba'zi deserialization zaifliklarini serialized obyektning attributlarini o'zgartirgan holda exploit qilish mumkin. Obyekt steyti doimo bir xil bo'lgani sabab, siz uni serialized holatini o'rganishingiz va undagi attributlarni tahrirlashingiz mumkin. Buni amalga oshirish bosqichi deserialization ni exploit qilishning boshlang'ich konsepsiyasi hisoblanadi.

Batafsilroq aytadigan bo'lsak serialized obyektni manipulatsiya qilishingiz uchun sizda ikkita yondashuv usuli bor. Siz uni to'g'ridan to'g'ri o'zgartirishingiz yoki mos keladigan dasturlash tilida skript yozib obyekt ichida yana obyekt tuzishingiz mumkin. Ikkinchi yondashuv usulini ikkilik sanoq sistemasida ishlaydigan serialization-da ishlatish qulay hisoblanadi.

### Obyekt attributlarini o'zgartirish <a href="#obyekt-attributlarini-ozgartirish" id="obyekt-attributlarini-ozgartirish"></a>

Ma'lumotni buzayotganda Haker valid bo'lgan serialized obyektni saqlab qola olsa, deserialization bo'layotganda attributlarning o'zgargan holatidagi, server-side obyekt hosil bo'ladi.

Bunga oddiy misol, cookie faylida foydalanuvchi sessiyasi haqidagi ma'lumotlarni saqlash uchun serialized `user` obyektidan foydalanadigan veb-saytni ko'zdan kechiring. Agar Haker uni HTTP request yuborish paytida aniqlasa, uni decode qilishi mumkin:

```php
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```

`isAdmin` attributi qiziqarli ko'rinmoqda. Haker undagi `b:0;` qiymatini `b:1;` ga o'zgartirib re-encode qilib qayta cookie ga joylab jo'natib admin bo'lishi mumkin. Izolyatsiyada, bu hech qanday ta'sir ko'rsatmaydi. Biroq, deylik, websayt ushbu cookie-fayldan joriy foydalanuvchining ma'lum administrativ funksiyalarga kirish huquqini tekshirish uchun foydalanadi:

```java
$user = unserialize($_COOKIE);
if ($user->isAdmin === true) {
//administrator paneliga kirishga ruxsat berish
}
```

Ushbu zaif kodda Haker tomonidan isAdmin attributiga o'zgartirish kiritilgan `User` obyektidagi ma'lumotni cookie deb o'rnatadi. Bunda hech qanday holatda serialized qilingan obyektlarning haqiqiyligi tekshirilmaydi. Keyin bu ma'lumot steyt tekshiruvidan o'tadi va osonlikcha imtiyozlarni oshirish imkonini beradi, ya'ni oddiy foydalanuvchi admin ga aylanadi.

Bu oddiy usul real hayotda unchalik ham keng tarqalmagan. Ammo attributlarni o'zgartirish **Insecure Deserialization** xujumlarini katta qismini birinchi qadami hisoblanadi.

:::caution **Lab**
 [Obyekt attributlarini o'zgartirish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects)
:::

### Ma'lumot turlarini o'zgartirish <a href="#malumot-turlarini-ozgartirish" id="malumot-turlarini-ozgartirish"></a>

Biz obyektlarning attribut qiymatlarini qanday qilib o'zgartirish mumkinligini ko'rib chiqdik, bundan tashqari yana web sayt kutmagan ma'lumot turlarni ham yuborishimiz mumkin.

PHPda turli malumot turlarini taqqoslashda == taqqoslash operatorining xatti harakatlari tufayli bu kabi manipulatsiyaga zaif hisoblanadi. Masalan siz integer va stringni taqqoslayotganingizda PHP stringni integer-ga aylantirishga harakat qiladi, ya'ni bu 5 == "5" true qiymatini berishini anglatadi.

Odatdagidek, bu raqam bilan boshlanadigan har qanday alfanumerik string uchun ham ishlaydi. Bu holatda PHP stringdagi raqamni to'g'ridan to'g'ri integerga o'zgartiradi. Stringning qolgan qismiga esa ahamiyat berilmayd. Bundan kelib chiqadiki `5 == "5 of something"` qiymatlarni taqqoslash 5 == 5 bo'ladi.

Yana bir g'alati taqqoslash bu, har qanday stringni 0 raqami bilan taqqoslasangiz paydo bo'ladi:

```
0 == "Example string" // true
```

Nega bunday ? Chunki bu yerda raqam yo'q va taqqoslanayotgan raqam bu nol, stringda esa raqamlar soni nolta, ya'ni umuman yo'q bo'lgani uchun.

Keling foydalanuvchini tomonidan kiritilgan ma'lumotlarni to'g'ri yoki noto'g'riligini tekshiruvchi funksiyada aynan ushbu taqqoslash usulidan foydalanilgan bo'lsa nima bo'ladi deb o'ylaysiz ? Bu juda xavfli hisoblanadi.

```php
$login = unserialize($_COOKIE)
if ($login['password'] == $password) {
// log in successfully
}
```

Deylik Haker password attributini string o'rniga 0 raqami bilan o'zgartirdi. Bilamizki parol hech qachon raqam bilan boshlanmaydi va bu holatda holatni tekshiruvchi funksiya har doim true qaytaradi va bu avtorizatsiyani aylanib o'tish imkonini beradi. E'tibor bering, bu faqat deserialization, ma'lumot turini saqlaganligi sababli shunday. Agar kod parolni to'g'ridan to'g'ri qabul qilib uni stringga aylantirsa unda holat tekshiruvchi funksiya `false` qaytaradi.

Shuni yodda tutingki, har qanday serialized obyekt formatida ma'lumot turlari o'zgartirilsa, serialized ma'lumotlardagi har qanday turdagi belgilarni va uzunlik indikatorlarini update qilishni ham unutmaslik kerak. Aks holda, serialized obyekt buziladi va deserialization qilinmaydi.

:::caution **Lab**
 [Serialized ma'lumot turlarini o'zgartirish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types)
:::

Agar siz ikkilik sanoq sistemasidagi serialized obyektlar bilan ishlayotgan bo'lsangiz unda sizga [Hackvertor extension](https://portswigger.net/bappstore/65033cbd2c344fbabe57ac060b5dd100)idan foydalanishni maslahat beramiz. Siz Hackvertor bilan serialized obyektni oddiy string kabi o'zgartirishingiz mumkin va u avtomatik tarzda o'zgargan ikkilik tizimiga o'tadi. Bu sizni ko'pgina qo'lda sinab ko'rishlardan asraydi.

## Websayt funksionalligidan foydalanish <a href="#websayt-funksionalligidan-foydalanish" id="websayt-funksionalligidan-foydalanish"></a>

Shunchaki atribut qiymatlarini tekshirish bilan bir qatorda, websayt funksionalligi deserialized obyekt ma'lumotlari ustida xavfli operatsiyalarni ham bajarishi mumkin. Bunday holda, siz kutilmagan ma'lumotlarni uzatish va zarar yetkazish maqsadida tegishli funktsiyalardan foydalanish uchun insecure deserialization-dan foydalanishingiz mumkin.

Masalan, websaytning "Foydalanuvchini o'chirish" funksiyasining bir qismi sifatida foydalanuvchining profil rasmi `$user->image_location` atributidagi fayl joylashuviga kirish orqali o'chiriladi. Agar bu `$user` serialized obyektdan yaratilgan boʻlsa, haker buni o'zgartirilgan obyektda, fayl joylashuvi o'tnatilgan `image_location` bilan aylanib o'tish orqali exploit qilishi mumkin. Foydalanuvchi o'z hisobini o'chirish bilan birgalikda ushbu faylni ham o'chiradi.

:::caution **Lab**
 [Insecure deserialization-ni exploit qilishda websayt funksionalligidan foydalanish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization)
:::

Ushbu misol hakerning xavfli metodni foydalanuvchi tomonidan boshqariladigan funksiyalar orqali qo'lbola tarzda amalga oshirishga tayanadi. Biroq, ma'lumotlarni xavfli metodlarga avtomatik ravishda o'tkazadigan exploitlarni yaratganingizda,insecure deserialization yanada qiziqarli bo'ladi. Bu "sehrli usullar" dan foydalanish orqali amalga oshiriladi.

## Magic metodlar <a href="#magic-metodlar" id="magic-metodlar"></a>

Magic (yoki dunder) metodlar, metodlarning maxsus to'plami bo'lib, siz ularni ishga tushirish uchun chaqirishingiz shart emas. Ularning o'zi ma'lum bir amal bajarilganda avtomatik tarzda chaqiriladi. Magic metodlar turli tillarda OOPning umumiy xususiyati hisoblandi. Ular ba'zan prefiks qo'yish yoki metod nomini ikkita pastki chiziq orasida yozish orqali ko'rsatiladi.

Ma'lum bir hodisa sodir bo'lganda qanday kod bajarilishi kerakligini oldindan belgilash uchun dasturchilar klassga magic metodlarni qo'shishlari mumkin. Aynan qachon va nima uchun magic metoddan foydalanish har bir metodda har xil bo'ladi. PHPdagi eng keng tarqalgan misollardan biri `__construct()` bo'lib, u har safar klass obyekti yaratilganda chaqiriladi, huddi Pythondagi `__init__` kabi. Odatda, constructor kabi, magic metodlar obyektning atributlarini ishga tushirish uchun kodni o'z ichiga oladi.

Biroq, magic metodlar dasturchilar tomonidan istalgan kodni bajarish uchun moslashtirilishi mumkin. Magic metodlar keng qo'llaniladi va o'z-o'zidan zaiflikni keltirib chiqarmaydi. Ammo ular bajarayotgan kod haker tomonidan boshqariladigan ma'lumotlarni, masalan serialized obyekt orqali ishga tushsa xavfli bo'lishi mumkin. Agar hacker conditionlarga mos keluvchi shartlarni bajarsa serialized ma'lumotlarda metodlarni avtomatik ravishda chaqirish uchun foydalanishi mumkin.

Bu yerdagi eng muhim narsa shuki ba'zi dasturlash tillari deserialization jarayonida magic metodlarni chaqiradilar. Masalan PHP ning unserialize() metodi obyektning \_\_wakeup() magic metodini qidiradi va uni chaqiradi.

Javadagi deserializationda xuddi shu narsa birinchi bayt oqimidan ma'lumotlarni o'qish uchun ishlatiladigan `ObjectInputStream.readObject()` metodiga taalluqlidir va asosan serialized obyektni "qayta ishga tushirish" uchun konstruktor vazifasini bajaradi. Biroq Serializable klasslar o'zining readObject() metodini quyidagi tarzda e'lon qilishlari mumkin:

```
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{
    // implementation
}
```

Aynan shu tarzda e'lon qilingan readObject() metodi deserialization paytida chaqiriladigan magic metod sifatida ishlaydi. Bu klassga o'z maydonlarining deserialization bo'lishini yanada diqqat bilan boshqarish imkonini beradi.

Ushbu turdagi magic metodlarni o'z ichiga olgan har qanday klasslarga e'tibor berishingiz kerak. Ular obyekt to'liq deserialization bo'lguniga qadar serialized obyektdan ma'lumotlarni websayt kodiga o'tkazishga imkon beradi. Bu yanada rivojlangan ekspluatatsiyalarni yaratish uchun boshlang'ich nuqtadir.

## Ixtiyoriy obyektlarni kiritish

Ixtiyoriy obketlarni qo'shish

Ko'rib turganimizdek, ba'zan veb-sayt tomonidan taqdim etilgan obyektni oddiygina tahrirlash orqali insecure deserializationni exploit qilishimiz mumkin. Biroq, ixtiyoriy obketlarni qo'shish'shish ko'plab imkoniyatlarni ochadi.

OOPda obyekt uchun mavjud bo'lgan metodlar uning klassiga qarab belgilanadi. Shu sababli, agar hacker serialized ma'lumotlar sifatida qaysi obyekt klassini uzatilayotganini manipulyatsiya qila olsa, ular serialized bo'lganidan keyin va hatto deserialization qilish paytida ham qanday kod ishga tushishiga ta'sir qilishi mumkin.

Deserialization metodlari, odatda deserialization qilingan narsalarni tekshirmaydi. Bu shuni anglatadiki, siz websaytda mavjud bo'lgan har qanday seriyali klass obyektlariga o'tishingiz mumkin va obyekt deserialized qilinadi. Bu hakerga ixtiyoriy klasslar misollarini yaratishga samarali imkon beradi. Ushbu obyekt kutilgan klassga tegishli emasligi muhim emas. Kutilmagan obyekt turi web sayt logikasida istisnoga olib kelishi mumkin, ammo zararli obyekt allaqachon yaratilgan bo'ladi.

Agar haker source kodga kirish imkoniga ega bo'lsa, ular barcha mavjud klasslarni batafsil o'rganishi mumkin. Oddiy ekspluatatsiyani yaratish uchun ular deserializationning magic metodlarini o'z ichiga olgan klasslarni izlaydilar, so'ngra ulardan birortasi boshqariladigan ma'lumotlar ustida xavfli operatsiyalarni bajarishini tekshiradi. Keyin haker ekspluatatsiya uchun magic metoddan foydalanish uchun ushbu klassning serialized obyektiga o'tishi mumkin.

:::caution **Lab**
 [PHPda ixtiyoriy obyektlarni kiritish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php)
:::

Ushbu deserialization magic metodlarini o'z ichiga olgan klasslar, "gadjet zanjiri" deb nomlanuvchi, metod chaqiruvlarining uzun seriyasini o'z ichiga olgan murakkabroq hujumlarni boshlash uchun ishlatilishi mumkin.

## Gadjet bog'lamlari

"Gadjet" - bu hackerga ma'lum bir maqsadga erishishda yordam beradigan web saytda mavjud bo'lgan kod snippeti. Individual gadjet foydalanuvchi inputi bilan bevosita hech qanday zararli ish qilmasligi mumkin. Hackerning maqsadi shunchaki o'z ma'lumotlarini boshqa gadjetga o'tkazadigan metodni ishga tushirish bo'lishi mumkin. Shu tarzda bir nechta gadjetlarni bir-biriga bog‘lash orqali hacker o‘z ma’lumotlarini xavfli “gadjet metod”iga o‘tkazishi mumkin, bu esa maksimal darajada zarar berishi mumkin.

Shuni tushunish kerakki, ba'zi boshqa ekspluatatsiya turlaridan farqli o'laroq, gadjetlar bog'lami hacker tomonidan tuzilgan bir biriga bog'langan metodlarning payloadi emas. Barcha kodlar allaqachon websaytda bor. Hacker nazorat qiladigan yagona narsa - bu gadjetlar zanjiriga uzatiladigan ma'lumotlardir. Bu odatda, deserialization paytida qo'llaniladigan magic metod yordamida amalga oshiriladi, ba'zida "kick-off gadget" deb nomlanadi.

Tashqarida faqat gadjet bo'g'lamidan foydalanish orqali ko'plab xavfli deserialization zaifliklaridan foydalanish mumkin bo'ladi. Bu ba'zan oddiy bir yoki ikki bosqichli janjir bo'lishi mumkin, ammo yuqori darajadagi jiddiy xujumlarni yaratish, ehtimol obyekt namunalari va metodlarni chaqirishning yanada murakkab ketma-ketligini talab qiladi. Shu sababli, gadjetlar bog'lamlarini yaratish imkoniyati insecure deserializationdan muvaffaqiyatli foydalanishning asosiy jihatlaridan biridir.

### Oldindan yaratilgan gadjet bo'g'lami bilan ishlash

Gadget bog'lamlarini qo'lda aniqlash juda mashaqqatli jarayon bo'lishi mumkin va manba kodiga kirmasdan turib aniqlash deyarli imkonsizdir. Yaxshiyamki, avval sinab ko'rishingiz mumkin bo'lgan oldindan yaratib qo'yilgan gadjet bo'g'lamlari bilan ishlashning bir nechta usullari bor.

Boshqa websaytlarda muvaffaqiyatli foydalanilgan bir qator oldindan tuzilgan bog'lamlarni taqdim qiladigan bir nechta vositalar mavjud. Harro manba kodiga kirish imkoniga ega bo'lmasangiz ham, ushbu vositalardan nisbatan kamroq kuch sarflagan holda insecure deserialization zaifliklarini aniqlash va ulardan foydalanishingiz mumkin. Ushbu yondashuv ekspluatatsiya qilinadigan gadjet bog'lamlarini o'z ichiga olgan kutubxonalardan keng foydalanganligi sababli samarali bo'ladi. Misol uchun, agar Java-ning Apache Commons Collections kutubxonasidagi gadjetlar zanjiri bitta websaytda ishlatilishi mumkin bo'lsa, ushbu kutubxonani amalga oshiradigan boshqa websaytlar ham xuddi shu zanjir yordamida ishlatilishi mumkin.

#### ysoserial

Java deserialization uchun shunday vositalardan biri "ysoserial" dir. Bu sizga target websayt foydalanayotgan deb hisoblangan kutubxona uchun taqdim etilgan gadjetlar bog'lamlaridan birini tanlash, so‘ngra bajarmoqchi bo‘lgan buyrug'ingizni yuborish imkonini beradi. Keyin tanlangan bog'lam asosida tegishli serialized obyektni yaratadi. Bunda ham ham ma'lum bir sinovlar va xatolar bo'ladi, ammo bu o'z gadjet zanjirlaringizni qo'lda yaratishdan ko'ra ancha kam mehnat talab qiladi.

:::caution **Lab**
 [Apache commons bilan java deserializationni exploit qilish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons)
:::

Esda tutingki, ysoserial-dagi barcha gadjetlar bog'lami ixtiyoriy kodni ishga tushirishga imkon bermaydi. Ammo buning o'rniga boshqa narsalar uchun foyda berishi mumkin. Misol uchun, siz deyarli har qanday serverda insecure deserializationni tezda aniqlashga yordam berish uchun quyidagilardan foydalanishingiz mumkin:

* `URLDNS` bo'g'lami berilgan URL uchun DNS qidiruvini amalga oshiradi. Eng muhimi, u ma'lum bir zaif kutubxonadan foydalangan holda target websaytga tayanmaydi va Javaning har qanday versiyasida ishlaydi. Bu narsa uni qidirilayotgan ma'lumotni aniqlash maqsadi uchun eng universal gadjetlar zanjiriga aylantiradi. Agar siz trafikda serialized obyektni topsangiz, Burp Collaborator bilan DNS o'zaro tasirini amalga oshiradigan obyektni yaratish uchun ushbu gadjet bog'lamidan foydalanib ko'rishingiz mumkin. Agar o'xshasa, target websaytda deserialization sodir bo'lganiga amin bo'lishingiz kerak.
* `JRMPClient` - dastlabki aniqlash uchun foydalanishingiz mumkin bo'lgan yana bir universal bo'glamdir. Bu serverni, berilgan IP manzilga TCP ulanishini o'rnatishga harakat qiladi. Hostname-ni emas, balki IP-manzilning o'zini berishingiz kerakligini unutmang. Bu bog'lam barcha chiquvchi trafik uchun firewall, shu jumladan DNS qidiruvi bo'lgan enviromentlarda foyda berishi mumkin. Siz ikki xil IP manzillar bilan payloadlarni yaratishga urinib ko'rishingiz mumkin: lokal va firewallga kiritilgan tashqi IP. Agar websayt lokal manzilga ega payload uchun darhol javob qaytarsayu, lekin tashqi IP manzilli payload uchun javob qaytarmasa yoki, javob qaytarishda kechikishiga sabab bo'lsa, bu serverning firewall bilan o'rnatilgan manzilga ulanishga uringani uchun gadjetlar zanjiri ishlaganligini ko'rsatadi. Bunday holda, javoblardagi vaqt farqi, hatto blind holatlarda ham serverda deserialization sodir bo'lganligini aniqlashga yordam beradi.

#### PHP Generic Gadget Chain-lar

Ko'pincha insecure deserialization zaifliklaridan aziyat chekadigan dasturlash tillarning ko'pchiligi PoC vositalariga ega. Masalan, PHP-ga asoslangan saytlar uchun siz "PHP General Gadget Chains" (PHPGGC) dan foydalanishingiz mumkin.

:::caution **Lab**
 [Avvaldan tuzib qo'yilgan gadjet bog'lamlari bilan PHP deserializationni exploit qilish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain)
:::

:::info **Eslatma**
Shuni ta'kidlash kerakki, zaiflik - bu websayt kodida yoki uning kutubxonalaridan birida gadjetlar bog'lamining mavjudligi emas, balki foydalanuvchi tomonidan boshqariladigan ma'lumotlarning deserialization qilinishidir. Gadjetlar bog'lami bog'langan ma'lumotlar kiritilgandan so'ng uning oqimini manipulyatsiya qilish vositasidir. Bu shuningdek, ishonchsiz ma'lumotlarning deserialization qilinishiga tayanadigan turli xil xotira buzilishi zaifliklariga ham tegishli. Boshqacha qilib aytganda, websayt har qanday gadjet zanjirini qandaydir tarzda ulashga muvaffaq bo'lsada, hali ham himoyasiz bo'lishi mumkin.
:::

### Qo'llanmasi mavjud gadjet bog'lami bilan ishlash

Target websayt tomonidan ishlatiladigan frameworkda ma'lum gadjet zanjirlaridan foydalanish uchun har doim ham maxsus tool bo'lmasligi mumkin. Bunday holda, siz qo'lda moslashtirishingiz mumkin bo'lgan hujjatlashtirilgan ekspluatatsiyalar bor-yo'qligini bilish uchun har doim internetni ko'zdan kechirish kerak bo'ladi. Kodni o'zgartirish, undagi dasturlash tilini va framework haqida ba'zi bir asosiy bilimlarni talab qilishi mumkin va siz ba'zan obyektni o'zingiz serialized qilishingiz kerak bo'lishi mumkin, ammo bu yondashuvda noldan ekspluatatsiya yaratishdan ko'ra ancha kam kuch sarflanadi.

:::caution **Lab**
 [Qo'llanmasi mavjud gadjet bog'lamlari bilan Ruby deserializationni exploit qilish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-ruby-deserialization-using-a-documented-gadget-chain)
:::

Foydalanishga tayyor gadjetlar bog'lamini topa olmasangiz ham, o'zingizning shaxsiy ekspluatatsiyangizni yaratishda yordam beradigan qimmatli bilimlarga ega bo'lishingiz mumkin.

## O'zingizning exploitingizni yaratish

Agarda off-the-shelf gadjet bog'lamlari va qo'llanmasi mavjud gadjet zanjirlari foyda bermasa unda siz o'zingizni exploitingizni yaratishingiz kerak bo'ladi.

O'z gadjetlar tarmog'ingizni muvaffaqiyatli yaratish uchun source kodga kirishingiz kerak bo'ladi. Birinchi qadam, deserialization paytida qo'llaniladigan magic metodni o'z ichiga olgan klassni aniqlash uchun ushbu source kodni o'rganishdir. Ushbu magic metod foydalanuvchi tomonidan boshqariladigan atributlar bilan to'g'ridan-to'g'ri biror xavfli narsa qila olish yoki qila olmaligini aniqlash uchun bajaradigan kodini o'rganing. Bu har doim tekshirishga arziydi.

Agar magic metod o'z-o'zidan ekspluatatsiya qilinmasa, u gadjetlar zanjiri uchun "boshlovchi gadjet" bo'lib xizmat qilishi mumkin. Kick-off gadjeti ishlatadigan har qanday metodlarni o'rganing. Ulardan birortasi siz nazorat qilayotgan maʼlumotlar bilan xavfli narsa qila oladimi ? Agar qila olmasa, ular keyinroq chaqiradigan metodlarning har birini batafsil ko'rib chiqing va hokazo.

Siz boshi berk ko'chaga kirib qolmaguningizgacha yoki boshqariladigan ma'lumotlaringiz uzatiladigan xavfli metod gadjetini aniqlamaguningizcha, qaysi qiymatlarga kira olishingiz mumkinligini kuzatib, ushbu jarayonni takrorlang.

Websayt kodi doirasida gadjetlar zanjirini qanday qilib muvaffaqiyatli yaratganingizdan so'ng, keyingi qadam payloadingizni o'z ichiga olgan serialized obyektni yaratishdir. Bu shunchaki boshlang'ich koddagi klass deklaratsiyasini o'rganish va ekspluatatsiya uchun zarur bo'lgan tegishli qiymatlarga ega haqiqiy serialized obyektni yaratish holati. Oldingi laboratoriyalarda ko'rganimizdek, bu stringga asoslangan serialization qilish formatlari bilan ishlashda nisbatan sodda.

Binar formatlar bilan ishlash, masalan, ayniqsa Java deserialization ekspluatatsiyasini yaratishda, qiyin bo'lishi mumkin. Mavjud obyektga kichik o'zgartirishlar kiritilganda, siz to'g'ridan-to'g'ri baytlar bilan ishlashingiz mumkin. Biroq, sezilarli o'zgarishlarni amalga oshirishda, masalan, butunlay yangi obyektga o'tishda, bu tezda amalga oshmaydi. Ma'lumotni o'zingiz yaratish va serialized qilish uchun target saytda foydalanilgan dasturlash tilida kodingizni yozish ko'pincha ancha oson.

O'zingizning gadjetlar bog'lmaingizni yaratishda, ikkinchi darajali zaifliklarni ishga tushirish uchun ushbu qo'shimcha xujum nuqtasidan foydalanish imkoniyatlariga e'tibor bering.

:::caution **Lab**
 [Java deserialization uchun shaxsiy gadjet zanjiringizni tuzish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-developing-a-custom-gadget-chain-for-java-deserialization)
:::

Source kodni sinchkovlik bilan o'rganib chiqib, uzunroq gadjet zanjirlarini topishingiz mumkin, ular sizga yuqori darajadagi jiddiy xujumlarni, jumladan, masofaviy kodni amalga oshirishga imkon beradi.

:::caution **Lab**
 [PHP deserialization uchun shaxsiy gadjet zanjiringizni tuzish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-developing-a-custom-gadget-chain-for-php-deserialization)
:::

## PHAR deserialization

Hozircha, biz birinchi navbatda, websayt foydalanuvchi kiritgan ma'lumotlarni deserialize qiluvchi deserialization zaifliklaridan foydalanishni ko'rib chiqdik. Biroq, PHPda ba'zan `unserialize()` metodidan foydalanilmagan bo'lsa ham, deserializationdan foydalanish mumkin.

PHP fayl joylashuvlariga kirishda turli protokollar bilan ishlash uchun foydalanishingiz mumkin bo'lgan bir nechta URL uslubidagi o'ramlarni taqdim etadi. Ulardan biri `phar://` wrapper bo'lib, u PHP Archive (.phar) fayllariga kirish uchun oqim interfeysini ta'minlaydi.

PHP qo'llanmasi PHAR manifest fayllarida ketma-ket metama'lumotlar borligini ko'rsatadi. Eng muhimi, agar siz `phar://` oqimida fayl tizimi operatsiyalarini bajarsangiz, bu metadata bilvosita deserialization bo'ladi. Bu shuni anglatadiki, agar siz ushbu oqimni fayl tizimi usuliga o'tkazishingiz mumkin bo'lsa, `phar://` oqimi potentsial ravishda insecure deserializationdan foydalanish uchun vektor bo'lishi mumkin.

`Include()` yoki `fopen()` kabi aniq xavfli fayl tizimi metodlari bo'lsa, websaytlar ulardan zararli maqsadlarda foydalanish potentsialini kamaytirish uchun qarshi choralar ko'rgan bo'lishi mumkin. Biroq, unchalik xavfli bo'lmagan `file_exists()` kabi metodlar u qadar yaxshi himoyalanmagan bo'lishi mumkin.

Shuningdek ushbu usul, PHARni qandaydir yo'l bilan serverga yuklashingizni talab qiladi. Masalan, rasm yuklash funksiyasidan foydalanib. Agar siz PHAR oddiy `JPG` formatidagi poliglot faylini yaratish imkoniga ega bo'lsangiz, ba'zan websaytning validatsiya tekshiruvlarini chetlab o'tishingiz mumkin. Agar websaytni ushbu poliglot "`JPG`"ni `phar://` oqimidan yuklashga majburlasangiz, PHAR metama'lumotlari orqali kiritilgan har qanday zararli maʼlumotlar deserialization bo'ladi. PHP oqimni o'qiyotganda fayl kengaytmasi tekshirilmaganligi sababli, fayl rasm kengaytmasidan foydalanishi muhim emas.

Obyekt klassi websayt tomonidan qo'llab-quvvatlanar ekan, `__wakeup()` va `__destruct()` magic metodlari shu tarzda qo'llanilishi mumkin, bu sizga ushbu texnikadan foydalangan holda gadjetlar zanjirini potentsial ravishda boshlash imkonini beradi.

:::caution **Lab**
 [Shaxsiy gadjet zanjiringizni deploy qilish uchun PHAR deserializationdan foydalanish ≫](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-phar-deserialization-to-deploy-a-custom-gadget-chain)
:::

Ushbu texnika 2018-yilning eng yaxshi 10 ta web-xakerlik texnikasi ro'yxatida keltirilgan.

:::info **Ko'proq o'qish**
**[2018-yilning eng yaxshi 10 ta web-xakerlik texnikasi ☰](https://portswigger.net/research/top-10-web-hacking-techniques-of-2018#6)**
:::

## Xotiraning buzilishidan foydalanib deserializationni exploit qilish

Gadjet bog'lamlaridan foydalanmasdan ham, insecure deserializationdan foydalanish mumkin. Agar barchasi muvaffaqiyatsiz bo'lsa, ko'pincha internetdagi qo'llanmalarda chiqarilgan xotira buzilishining zaifliklari mavjud bo'lib, ulardan insecure deserialization orqali foydalanish mumkin. Bular odatda masofadan kod bajarilishiga olib keladi. PHP ning `unserialize()` kabi deserialization metodlari kamdan-kam hollarda bunday hujumlarga himoyalangan bo'ladi va katta miqdordagi xujum nuqtasini aniqlab beradi. Bu har doim ham o'z-o'zidan zaiflik deb hisoblanmaydi, chunki bu usullar birinchi navbatda foydalanuvchi tomonidan boshqariladigan inputni boshqarish uchun mo'ljallanmagan.
